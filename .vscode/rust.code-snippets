{
	// Place your sample-rust ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"atcoder base": {
		"scope": "rust",
		"prefix": "atcoder",
		"body": [
			"fn read_line() -> String {",
			"\tlet mut line = String::new();",
			"\tstd::io::stdin().read_line(&mut line).unwrap();",
			"\tline.trim_end().to_owned()",
			"}",
			"",
			"fn main() {",
			"\tlet stdin = read_line();",
			"\tlet stdout = solve(&stdin);",
			"\tstdout.iter().for_each(|s| {",
			"\t\tprintln!(\"{}\", s);",
			"\t})",
			"}",
			"",
			"fn solve(s: &str) -> Vec<String> {",
			"\tlet mut buf = Vec::new();",
			"\tbuf.push(format!(\"{}\", s));",
			"\tbuf",
			"}",
			"",
			"#[test]",
			"fn test_solve_1() {",
			"\tassert_eq!(solve(\"1\"), vec!(\"1\"));",
			"}"
		],
		"description": "Base code for atcoder"
	},
	"Input stdin as single value": {
		"scope": "rust",
		"prefix": "input stdin as single values",
		"body": [
			"let ${1:v} = read_line().parse().unwrap();",
		],
		"description": "標準入力から値取得"
	},
	"Input stdin as multi values": {
		"scope": "rust",
		"prefix": "input stdin as multi values",
		"body": [
			"let mut stdin  = read_line();",
			"let mut iter  = stdin.split_whitespace();",
			"let ${1:v1} = iter.next().unwrap().parse().unwrap();",
			"let ${2:v2} = iter.next().unwrap().parse().unwrap();",
		],
		"description": "標準入力から値取得（複数値）"
	},
	"Input stdin as vector": {
		"scope": "rust",
		"prefix": "input stdin as vector",
		"body": [
			"let ${1:v} = read_line().split_whitespace().map(|v| v.parse().unwrap()).collect();",
		],
		"description": "標準入力から値取得（Vec型）"
	},
	"is_prime": {
		"scope": "rust",
		"prefix": "is_prime",
		"body": [
			"fn is_prime(n: u64) -> bool {",
			"\tif n == 2 {",
			"\t\treturn true;",
			"\t}",
			"\tif n == 0 || n == 1 || n % 2 == 0 {",
			"\t\treturn false;",
			"\t}",
			"",
			"\tlet mut i: u64 = 3;",
			"\twhile i * i <= n {",
			"\t\tif n % i == 0 {",
			"\t\t\treturn false;",
			"\t\t}",
			"",
			"\t\ti += 2;",
			"\t}",
			"",
			"\ttrue",
			"}"
		],
		"description": "素数判定"
	},
	"enum_divisors": {
		"scope": "rust",
		"prefix": "enum_divisors",
		"body": [
			"fn enum_divisors(n: u64) -> HashSet<u64> {",
			"\tlet mut divisors = HashSet::new();",
			"\tif n == 0 {",
			"\t\treturn divisors;",
			"\t}",
			"",
			"\tlet mut i: u64 = 1;",
			"\twhile i * i <= n {",
			"\t\tif n % i == 0 {",
			"\t\t\tdivisors.insert(i);",
			"\t\t\tdivisors.insert(n / i);",
			"\t\t}",
			"",
			"\t\ti += 1;",
			"\t}",
			"",
			"\tdivisors",
			"}"
		],
		"description": "約数列挙"
	},
	"prime_factorize": {
		"scope": "rust",
		"prefix": "prime_factorize",
		"body": [
			"fn prime_factorize(mut n: u64) -> HashMap<u64, u64> {",
			"\tlet mut ans = HashMap::new();",
			"\tlet mut i = 2;",
			"\twhile i * i <= n {",
			"\t\tif n % i == 0 {",
			"\t\t\tlet mut ex = 0;",
			"\t\t\twhile n % i == 0 {",
			"\t\t\t\tex += 1;",
			"\t\t\t\tn = n / i;",
			"\t\t\t}",
			"\t\t\tans.insert(i, ex);",
			"\t\t}",
			"\t\ti += 1;",
			"\t}",
			"\tif n > 1 {",
			"\t\tans.insert(n, 1);",
			"\t}",
			"",
			"\tans",
			"}",
		],
		"description": "素因数分解"
	},
	"greatest_common_divisor": {
		"scope": "rust",
		"prefix": "greatest_common_divisor",
		"body": [
			"fn gcd(a: u64, b: u64) -> u64 {",
			"\tif b == 0 {",
			"\t\ta",
			"\t} else {",
			"\t\tgcd(b, a % b)",
			"\t}",
			"}"
		],
		"description": "最大公約数"
	}
}