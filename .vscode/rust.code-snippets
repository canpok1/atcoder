{
	// Place your sample-rust ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"atcoder main": {
		"scope": "rust",
		"prefix": "atcoder main",
		"body": [
			"fn main() {",
			"\tlet solver = Solver::new(read_line());",
			"\tlet stdout = solver.solve();",
			"\tstdout.iter().for_each(|s| {",
			"\t\tprintln!(\"{}\", s);",
			"\t})",
			"}",
			"",
			"struct Solver {",
			"\ts: String,",
			"}",
			"",
			"impl Solver {",
			"\tfn new(s: String) -> Solver {",
			"\t\tSolver { s: s }",
			"\t}",
			"",
			"\tfn solve(&self) -> Vec<String> {",
			"\t\tlet mut buf = Vec::new();",
			"\t\tbuf.push(format!(\"{}\", self.s));",
			"\t\tbuf",
			"\t}",
			"}",
		],
		"description": "Base code for atcoder"
	},
	"atcoder test": {
		"scope": "rust",
		"prefix": "atcoder test",
		"body": [
			"#[test]",
			"fn test_solve_1() {",
			"\tlet solver = Solver::new(\"1\".to_owned());",
			"\tassert_eq!(solver.solve(), vec!(\"1\"));",
			"}",
		],
		"description": "テストコード"
	},
	"read_line": {
		"scope": "rust",
		"prefix": "myfunc read_line",
		"body": [
			"fn read_line() -> String {",
			"\tlet mut line = String::new();",
			"\tstd::io::stdin().read_line(&mut line).unwrap();",
			"\tline.trim_end().to_owned()",
			"}",
		],
		"description": "標準入力から文字列取得"
	},
	"Input stdin as single value": {
		"scope": "rust",
		"prefix": "input stdin as single values",
		"body": [
			"let ${1:v} = read_line().parse().unwrap();",
		],
		"description": "標準入力から値取得"
	},
	"Input stdin as multi values": {
		"scope": "rust",
		"prefix": "input stdin as multi values",
		"body": [
			"let stdin  = read_line();",
			"let mut iter  = stdin.split_whitespace();",
			"let ${1:v1} = iter.next().unwrap().parse().unwrap();",
			"let ${2:v2} = iter.next().unwrap().parse().unwrap();",
		],
		"description": "標準入力から値取得（複数値）"
	},
	"Input stdin as vector": {
		"scope": "rust",
		"prefix": "input stdin as vector",
		"body": [
			"let ${1:v} = read_line().split_whitespace().map(|v| v.parse().unwrap()).collect();",
		],
		"description": "標準入力から値取得（Vec型）"
	},
	"is_prime": {
		"scope": "rust",
		"prefix": "myfunc is_prime",
		"body": [
			"fn is_prime(n: ${1:u64}) -> bool {",
			"\tif n == 2 {",
			"\t\treturn true;",
			"\t}",
			"\tif n == 0 || n == 1 || n % 2 == 0 {",
			"\t\treturn false;",
			"\t}",
			"",
			"\tlet mut i = 3;",
			"\twhile i * i <= n {",
			"\t\tif n % i == 0 {",
			"\t\t\treturn false;",
			"\t\t}",
			"",
			"\t\ti += 2;",
			"\t}",
			"",
			"\ttrue",
			"}"
		],
		"description": "素数判定"
	},
	"enum_divisors": {
		"scope": "rust",
		"prefix": "myfunc enum_divisors",
		"body": [
			"fn enum_divisors(n: ${1:u64}) -> HashSet<${1:u64}> {",
			"\tlet mut divisors = HashSet::new();",
			"\tif n == 0 {",
			"\t\treturn divisors;",
			"\t}",
			"",
			"\tlet mut i = 1;",
			"\twhile i * i <= n {",
			"\t\tif n % i == 0 {",
			"\t\t\tdivisors.insert(i);",
			"\t\t\tdivisors.insert(n / i);",
			"\t\t}",
			"",
			"\t\ti += 1;",
			"\t}",
			"",
			"\tdivisors",
			"}"
		],
		"description": "約数列挙"
	},
	"prime_factorize": {
		"scope": "rust",
		"prefix": "myfunc_prime_factorize",
		"body": [
			"fn prime_factorize(mut n: ${1:u64}) -> HashMap<${1:u64}, ${1:u64}> {",
			"\tlet mut ans = HashMap::new();",
			"\tlet mut i = 2;",
			"\twhile i * i <= n {",
			"\t\tif n % i == 0 {",
			"\t\t\tlet mut ex = 0;",
			"\t\t\twhile n % i == 0 {",
			"\t\t\t\tex += 1;",
			"\t\t\t\tn = n / i;",
			"\t\t\t}",
			"\t\t\tans.insert(i, ex);",
			"\t\t}",
			"\t\ti += 1;",
			"\t}",
			"\tif n > 1 {",
			"\t\tans.insert(n, 1);",
			"\t}",
			"",
			"\tans",
			"}",
		],
		"description": "素因数分解"
	},
	"greatest_common_divisor": {
		"scope": "rust",
		"prefix": "myfunc_greatest_common_divisor",
		"body": [
			"fn gcd(a: ${1:u64}, b: ${1:u64}) -> ${1:u64} {",
			"\tif b == 0 {",
			"\t\ta",
			"\t} else {",
			"\t\tgcd(b, a % b)",
			"\t}",
			"}"
		],
		"description": "最大公約数"
	}
}