{
  "matrix3": {
    "prefix": "matrix3",
    "body": [
      "type Matrix3 = Vec<Vec<i64>>;",
      "#[allow(dead_code)]",
      "fn unit_matrix3() -> Matrix3 {",
      "    vec![vec![1, 0, 0], vec![0, 1, 0], vec![0, 0, 1]]",
      "}",
      "#[allow(dead_code)]",
      "fn matmul(m1: &Matrix3, m2: &Matrix3) -> Matrix3 {",
      "    vec![",
      "        vec![",
      "            m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0] + m1[0][2] * m2[2][0],",
      "            m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1] + m1[0][2] * m2[2][1],",
      "            m1[0][0] * m2[0][2] + m1[0][1] * m2[1][2] + m1[0][2] * m2[2][2],",
      "        ],",
      "        vec![",
      "            m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0] + m1[1][2] * m2[2][0],",
      "            m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1] + m1[1][2] * m2[2][1],",
      "            m1[1][0] * m2[0][2] + m1[1][1] * m2[1][2] + m1[1][2] * m2[2][2],",
      "        ],",
      "        vec![",
      "            m1[2][0] * m2[0][0] + m1[2][1] * m2[1][0] + m1[2][2] * m2[2][0],",
      "            m1[2][0] * m2[0][1] + m1[2][1] * m2[1][1] + m1[2][2] * m2[2][1],",
      "            m1[2][0] * m2[0][2] + m1[2][1] * m2[1][2] + m1[2][2] * m2[2][2],",
      "        ],",
      "    ]",
      "}"
    ]
  },
  "myfunc binary_search": {
    "prefix": "myfunc binary_search",
    "body": [
      "#[allow(dead_code)]",
      "fn binary_search<F>(mut ng_idx: i64, mut ok_idx: i64, is_ok: F) -> (i64, i64)",
      "where",
      "    F: Fn(i64) -> bool,",
      "{",
      "    while (ok_idx - ng_idx).abs() > 1 {",
      "        let mid_idx = (ok_idx + ng_idx) / 2;",
      "        if is_ok(mid_idx) {",
      "            ok_idx = mid_idx;",
      "        } else {",
      "            ng_idx = mid_idx;",
      "        }",
      "    }",
      "    (ng_idx, ok_idx)",
      "}"
    ]
  },
  "myfunc enum_divisors": {
    "prefix": "myfunc enum_divisors",
    "body": [
      "use std::collections::HashSet;",
      "#[allow(dead_code)]",
      "fn enum_divisors(n: u64) -> HashSet<u64> {",
      "    let mut divisors = HashSet::new();",
      "    if n == 0 {",
      "        return divisors;",
      "    }",
      "    let mut i = 1;",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            divisors.insert(i);",
      "            divisors.insert(n / i);",
      "        }",
      "        i += 1;",
      "    }",
      "    divisors",
      "}"
    ]
  },
  "myfunc gcd": {
    "prefix": "myfunc gcd",
    "body": [
      "#[allow(dead_code)]",
      "fn gcd(a: u64, b: u64) -> u64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "myfunc graph dijkstra": {
    "prefix": "myfunc graph dijkstra",
    "body": [
      "use std::cmp::Ordering;",
      "use std::collections::BinaryHeap;",
      "#[derive(Eq, PartialEq, PartialOrd)]",
      "struct Node {",
      "    cost: i64,",
      "    index: usize,",
      "}",
      "impl Ord for Node {",
      "    fn cmp(&self, other: &Self) -> Ordering {",
      "        other.cost.cmp(&self.cost)",
      "    }",
      "}",
      "struct Edge {",
      "    from: usize,",
      "    to: usize,",
      "    cost: i64,",
      "}",
      "#[allow(dead_code)]",
      "fn dijkstra(n: usize, edges: &Vec<Edge>, start: usize, goal: usize) -> Option<i64> {",
      "    const INIT_COST: i64 = std::i64::MAX;",
      "    let mut costs: Vec<_> = (0..n).map(|_| INIT_COST).collect();",
      "    let mut queue = BinaryHeap::new();",
      "    costs[start] = 0;",
      "    queue.push(Node {",
      "        cost: 0,",
      "        index: start,",
      "    });",
      "    while let Some(current) = queue.pop() {",
      "        if current.cost > costs[current.index] {",
      "            continue;",
      "        }",
      "        for edge in edges {",
      "            if edge.from != current.index {",
      "                continue;",
      "            }",
      "            let next = Node {",
      "                cost: current.cost + edge.cost,",
      "                index: edge.to,",
      "            };",
      "            if next.cost < costs[next.index] {",
      "                costs[next.index] = next.cost;",
      "                queue.push(next);",
      "            }",
      "        }",
      "    }",
      "    if costs[goal] == INIT_COST {",
      "        None",
      "    } else {",
      "        Some(costs[goal])",
      "    }",
      "}"
    ]
  },
  "myfunc is_prime": {
    "prefix": "myfunc is_prime",
    "body": [
      "#[allow(dead_code)]",
      "fn is_prime(n: u64) -> bool {",
      "    if n == 2 {",
      "        return true;",
      "    }",
      "    if n == 0 || n == 1 || n % 2 == 0 {",
      "        return false;",
      "    }",
      "    let mut i = 3;",
      "    while i * i <= n {",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "        i += 2;",
      "    }",
      "    true",
      "}"
    ]
  },
  "myfunc lcm": {
    "prefix": "myfunc lcm",
    "body": [
      "#[allow(dead_code)]",
      "fn lcm(a: u64, b: u64) -> u64 {",
      "    a * b / gcd(a, b)",
      "}"
    ]
  },
  "myfunc prime_factorize": {
    "prefix": "myfunc prime_factorize",
    "body": [
      "use std::collections::HashMap;",
      "#[allow(dead_code)]",
      "fn prime_factorize(n: u64) -> HashMap<u64, u64> {",
      "    let mut ans = HashMap::new();",
      "    let mut i = 2;",
      "    let mut nn = n;",
      "    while i * i <= nn {",
      "        if nn % i == 0 {",
      "            let mut ex = 0;",
      "            while nn % i == 0 {",
      "                ex += 1;",
      "                nn = nn / i;",
      "            }",
      "            ans.insert(i, ex);",
      "        }",
      "        i += 1;",
      "    }",
      "    if nn > 1 {",
      "        ans.insert(nn, 1);",
      "    }",
      "    ans",
      "}"
    ]
  },
  "myfunc read_line": {
    "prefix": "myfunc read_line",
    "body": [
      "#[allow(dead_code)]",
      "fn read_line() -> String {",
      "    let mut line = String::new();",
      "    std::io::stdin().read_line(&mut line).unwrap();",
      "    line.trim_end().to_owned()",
      "}"
    ]
  }
}
